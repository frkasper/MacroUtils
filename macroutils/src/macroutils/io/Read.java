package macroutils.io;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import macroutils.MacroUtils;
import macroutils.StaticDeclarations;
import macroutils.UserDeclarations;
import star.base.neo.DoubleVector;
import star.common.Simulation;
import star.vis.VisProjectionMode;
import star.vis.VisView;

/**
 * Low-level class for reading objects in general with MacroUtils.
 *
 * @since April of 2016
 * @author Fabio Kasper
 */
public class Read {

    private macroutils.getter.MainGetter _get = null;
    private macroutils.io.MainIO _io = null;
    private MacroUtils _mu = null;
    private Simulation _sim = null;
    private macroutils.UserDeclarations _ud = null;

    /**
     * Main constructor for this class.
     *
     * @param m given MacroUtils object.
     */
    public Read(MacroUtils m) {
        _mu = m;
        _sim = m.getSimulation();
    }

    /**
     * Reads a Camera string generated by {@link Write#cameraViews} and then creates a new Camera
     * View.
     *
     * @param cam given camera string.
     * @param vo  given verbose option. False will not print anything.
     * @return The VisView.
     */
    public VisView cameraView(String cam, boolean vo) {
        _io.say.action("Reading a Camera View", vo);
        _io.say.value("Camera string", cam, true, vo);
        String[] props = cam.split("\\" + StaticDeclarations.CAM_SPLIT_CHAR_FIELDS);
        _io.say.msgDebug("Props: " + _get.strings.fromArray(props));
        VisView vv0 = _get.cameras.byREGEX(props[0], false);
        if (vv0 != null) {
            _io.say.msg("Already exists. Skipping...", vo);
            return vv0;
        }
        VisView vv1 = _sim.getViewManager().createView();
        vv1.setPresentationName(props[0]);
        //--
        DoubleVector dv = new DoubleVector(macroutils.StaticDeclarations.COORD0);
        //--
        for (int i = 1; i <= 3; i++) {
            String[] items = props[i].split(",");
            for (int j = 0; j < items.length; j++) {
                dv.setElementAt(Double.valueOf(items[j]), j);
            }
            switch (i) {
                case 1:
                    vv1.setFocalPoint(dv);
                    _io.say.value("Focal Point read", dv, true);
                    break;
                case 2:
                    vv1.setPosition(dv);
                    _io.say.value("Position read", dv, true);
                    break;
                case 3:
                    vv1.setViewUp(dv);
                    _io.say.value("View Up read", dv, true);
                    break;
            }
        }
        double ps = Double.parseDouble(props[4]);
        vv1.getParallelScale().getScale().setValue(ps);
        _io.say.value("Parallel Scale read", ps, true);
        vv1.setProjectionMode(VisProjectionMode.PARALLEL);
        _io.say.camera(vv1, vo);
        return vv1;
    }

    /**
     * Reads all Camera Views stored in a file and create them to be used in STAR-CCM+.
     *
     * Note that the Cameras must be in the same format as defined in {@link Write#cameraViews}.
     *
     * @param filename given filename. File will be read from {@link UserDeclarations#simPath}
     *                 folder.
     */
    public void cameraViews(String filename) {
        _io.say.action("Reading Camera Views", true);
        File camFile = new File(_ud.simPath, filename);
        String camData = data(camFile, false);
        _io.say.value("Camera File", camFile.getAbsolutePath(), true, true);
        String[] cams = camData.split("\n");
        for (int i = 0; i < cams.length; i++) {
            _io.say.msg(true, "Processing Camera View: %d...", i + 1);
            try {
                VisView vv = cameraView(cams[i], false);
                _io.say.object(vv, true);
            } catch (Exception e) {
                _io.say.msg("Unable to process Camera View.");
                _io.say.msg(e.getMessage());
            }
        }
    }

    /**
     * Reads the contents from a file.
     *
     * @param f  given File as {@link java.io.File} format.
     * @param vo given verbose option. False will not print anything.
     * @return The data as String.
     */
    public String data(File f, boolean vo) {
        _io.say.action("Reading Data", vo);
        StringBuilder contents = new StringBuilder();
        try {
            BufferedReader input = new BufferedReader(new FileReader(f));
            try {
                String line = null;
                while ((line = input.readLine()) != null) {
                    contents.append(line);
                    contents.append(System.getProperty("line.separator"));
                }
            } finally {
                input.close();
            }
        } catch (IOException ex) {
            _io.say.msg(vo, ex.getMessage());
            _io.say.value("Unable to read from file", f.toString(), true, vo);
        }
        _io.say.ok(vo);
        return contents.toString();
    }

    /**
     * This method is called automatically by {@link MainIO} class. It is internal to MacroUtils.
     */
    public void updateInstances() {
        _get = _mu.get;
        _io = _mu.io;
        _ud = _mu.userDeclarations;
    }

}
